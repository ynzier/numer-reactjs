{"ast":null,"code":"const express = require('express');\n\nconst router = express.Router();\n\nconst math = require('mathjs');\n\nexport default function BisecAPI() {\n  router.post('/bisecapi', (req, res) => {\n    console.log('Bisec API');\n    var xl = parseFloat(req.body.xl);\n    var xr = parseFloat(req.body.xr);\n    const equation = math.compile(req.body.equation);\n    var xm = 0;\n    var check = parseFloat(0.0000000);\n    var n = 0;\n    var tmpArr = [];\n\n    do {\n      xm = findxm(xl, xr);\n      console.log(check); //error\n\n      n++;\n      console.log(n);\n\n      if (funcal(xl) * funcal(xm) > 0) {\n        check = Math.abs((xm - xl) / xm).toFixed(8);\n        xl = xm;\n      } else {\n        check = Math.abs((xm - xr) / xm).toFixed(8);\n        xr = xm;\n      }\n\n      console.log('iteration: ', n, ' Xl: ', xl, ' XR: ', xr, ' XM: ', xm);\n      tmpArr.push({\n        'iteration': n,\n        'xl': xl,\n        'xr': xr,\n        'xm': xm,\n        'Error': check\n      });\n    } while (check > 0.000001 || n < 20);\n\n    const findxm = (xl, xr) => {\n      return (parseFloat(xl) + parseFloat(xr)) / 2;\n    };\n\n    const funcal = X => {\n      const expression = equation;\n      const expr = math.compile(expression);\n      let scope = {\n        x: parseFloat(X)\n      };\n      return expr.evaluate(scope);\n    };\n\n    res.json({\n      tmpArr: tmpArr\n    });\n  });\n  module.exports = router;\n}\n_c = BisecAPI;\n\nvar _c;\n\n$RefreshReg$(_c, \"BisecAPI\");","map":{"version":3,"sources":["C:/numer_site/src/api/BisectionAPI.js"],"names":["express","require","router","Router","math","BisecAPI","post","req","res","console","log","xl","parseFloat","body","xr","equation","compile","xm","check","n","tmpArr","findxm","funcal","Math","abs","toFixed","push","X","expression","expr","scope","x","evaluate","json","module","exports"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMC,MAAM,GAAGF,OAAO,CAACG,MAAR,EAAf;;AACA,MAAMC,IAAI,GAAGH,OAAO,CAAC,QAAD,CAApB;;AAEA,eAAe,SAASI,QAAT,GAAmB;AAElCH,EAAAA,MAAM,CAACI,IAAP,CAAY,WAAZ,EAAyB,CAACC,GAAD,EAAMC,GAAN,KAAc;AACrCC,IAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ;AACA,QAAIC,EAAE,GAAGC,UAAU,CAACL,GAAG,CAACM,IAAJ,CAASF,EAAV,CAAnB;AACA,QAAIG,EAAE,GAAGF,UAAU,CAACL,GAAG,CAACM,IAAJ,CAASC,EAAV,CAAnB;AACA,UAAMC,QAAQ,GAAGX,IAAI,CAACY,OAAL,CAAaT,GAAG,CAACM,IAAJ,CAASE,QAAtB,CAAjB;AACA,QAAIE,EAAE,GAAG,CAAT;AACA,QAAIC,KAAK,GAAGN,UAAU,CAAC,SAAD,CAAtB;AACA,QAAIO,CAAC,GAAC,CAAN;AACA,QAAIC,MAAM,GAAG,EAAb;;AAGA,OAAE;AACEH,MAAAA,EAAE,GAAGI,MAAM,CAACV,EAAD,EAAIG,EAAJ,CAAX;AAEAL,MAAAA,OAAO,CAACC,GAAR,CAAYQ,KAAZ,EAHF,CAGqB;;AACnBC,MAAAA,CAAC;AACDV,MAAAA,OAAO,CAACC,GAAR,CAAYS,CAAZ;;AACA,UAAGG,MAAM,CAACX,EAAD,CAAN,GAAWW,MAAM,CAACL,EAAD,CAAjB,GAAsB,CAAzB,EAA4B;AAC1BC,QAAAA,KAAK,GAACK,IAAI,CAACC,GAAL,CAAS,CAACP,EAAE,GAACN,EAAJ,IAAQM,EAAjB,EAAqBQ,OAArB,CAA6B,CAA7B,CAAN;AACAd,QAAAA,EAAE,GAAIM,EAAN;AACD,OAHD,MAIK;AACHC,QAAAA,KAAK,GAACK,IAAI,CAACC,GAAL,CAAS,CAACP,EAAE,GAACH,EAAJ,IAAQG,EAAjB,EAAqBQ,OAArB,CAA6B,CAA7B,CAAN;AACAX,QAAAA,EAAE,GAAIG,EAAN;AACD;;AACDR,MAAAA,OAAO,CAACC,GAAR,CAAY,aAAZ,EAA2BS,CAA3B,EAA8B,OAA9B,EAAsCR,EAAtC,EAAyC,OAAzC,EAAiDG,EAAjD,EAAoD,OAApD,EAA4DG,EAA5D;AAEAG,MAAAA,MAAM,CAACM,IAAP,CAAY;AACV,qBAAaP,CADH;AAEV,cAAMR,EAFI;AAGV,cAAMG,EAHI;AAIV,cAAMG,EAJI;AAKV,iBAASC;AALC,OAAZ;AAQD,KAxBH,QAwBSA,KAAK,GAAC,QAAN,IAAkBC,CAAC,GAAC,EAxB7B;;AA2BE,UAAME,MAAM,GAAG,CAACV,EAAD,EAAIG,EAAJ,KAAW;AACxB,aAAO,CAACF,UAAU,CAACD,EAAD,CAAV,GAAeC,UAAU,CAACE,EAAD,CAA1B,IAAgC,CAAvC;AACD,KAFD;;AAGA,UAAMQ,MAAM,GAAIK,CAAD,IAAO;AACpB,YAAMC,UAAU,GAAGb,QAAnB;AACA,YAAMc,IAAI,GAAGzB,IAAI,CAACY,OAAL,CAAaY,UAAb,CAAb;AACA,UAAIE,KAAK,GAAG;AAACC,QAAAA,CAAC,EAACnB,UAAU,CAACe,CAAD;AAAb,OAAZ;AACA,aAAOE,IAAI,CAACG,QAAL,CAAcF,KAAd,CAAP;AACD,KALD;;AAOAtB,IAAAA,GAAG,CAACyB,IAAJ,CAAS;AACPb,MAAAA,MAAM,EAAEA;AADD,KAAT;AAMD,GAtDH;AAwDAc,EAAAA,MAAM,CAACC,OAAP,GAAiBjC,MAAjB;AACC;KA3DuBG,Q","sourcesContent":["const express = require('express');\r\nconst router = express.Router();\r\nconst math = require('mathjs');\r\n\r\nexport default function BisecAPI(){\r\n\r\nrouter.post('/bisecapi', (req, res) => {\r\n  console.log('Bisec API')\r\n  var xl = parseFloat(req.body.xl);\r\n  var xr = parseFloat(req.body.xr);\r\n  const equation = math.compile(req.body.equation);\r\n  var xm = 0;\r\n  var check = parseFloat(0.0000000);\r\n  var n=0;\r\n  var tmpArr = [];\r\n\r\n\r\n  do{   \r\n      xm = findxm(xl,xr);\r\n      \r\n      console.log(check);//error\r\n      n++;\r\n      console.log(n);\r\n      if(funcal(xl)*funcal(xm)>0) {\r\n        check=Math.abs((xm-xl)/xm).toFixed(8);\r\n        xl = (xm);\r\n      }\r\n      else {\r\n        check=Math.abs((xm-xr)/xm).toFixed(8);\r\n        xr = (xm);\r\n      }\r\n      console.log('iteration: ' ,n, ' Xl: ',xl,' XR: ',xr,' XM: ',xm);\r\n\r\n      tmpArr.push({\r\n        'iteration': n,\r\n        'xl': xl,\r\n        'xr': xr,\r\n        'xm': xm,\r\n        'Error': check,\r\n      });\r\n      \r\n    }while(check>0.000001 || n<20)\r\n\r\n\r\n    const findxm = (xl,xr) => {\r\n      return (parseFloat(xl)+parseFloat(xr))/2\r\n    }\r\n    const funcal = (X) => {\r\n      const expression = equation;\r\n      const expr = math.compile(expression);\r\n      let scope = {x:parseFloat(X)};\r\n      return expr.evaluate(scope);\r\n    }\r\n\r\n    res.json({\r\n      tmpArr: tmpArr\r\n  })\r\n\r\n\r\n\r\n  }\r\n);\r\nmodule.exports = router;\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}